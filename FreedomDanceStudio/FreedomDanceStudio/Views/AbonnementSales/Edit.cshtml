@model AbonnementSale
@{
    ViewData["Title"] = "Редактирование продажи абонемента";
}

<div class="container mt-4">
    <h2>@ViewData["Title"]</h2>

    <form method="post">
        <input type="hidden" asp-for="Id" />

        <div class="row">
            <div class="col-md-6">
                <!-- Поле выбора клиента -->
                <div class="mb-3">
                    <label asp-for="ClientId" class="form-label">Клиент</label>
                    <select asp-for="ClientId" asp-items="ViewBag.Clients"
                            class="form-select" required>
                        <option value="">-- Выберите клиента --</option>
                    </select>
                    <span asp-validation-for="ClientId" class="text-danger"></span>
                </div>

                <!-- Поле выбора услуги -->
                <div class="mb-3">
                    <label asp-for="ServiceId" class="form-label">Тип абонемента</label>
                    <select asp-for="ServiceId" asp-items="ViewBag.Services"
                            class="form-select" required id="ServiceSelect">
                        <option value="">-- Выберите услугу --</option>
                    </select>
                    <span asp-validation-for="ServiceId" class="text-danger"></span>
                </div>

                <!-- Дата продажи (только для чтения) -->
                <div class="mb-3">
                    <label asp-for="SaleDate" class="form-label">Дата продажи</label>
                    <input asp-for="SaleDate" type="date" class="form-control"
                           asp-format="{0:yyyy-MM-dd}"
                           value="@Model.SaleDate.ToString("yyyy-MM-dd")" readonly/>
                    <span asp-validation-for="SaleDate" class="text-danger"></span>
                </div>

                <!-- Блок с информацией о выбранной услуге -->
                <div id="ServiceInfo" class="alert alert-info mb-3" style="display:none;">
                    <strong>Выбрана услуга:</strong> <span id="ServiceNameDisplay"></span><br>
                    <strong>Цена:</strong> <span id="PriceDisplay"></span> ₽<br>
                    <strong>Срок действия:</strong> <span id="DurationDisplay"></span> дней
                </div>

                <!-- Начало действия (только для чтения, сохраняется исходное значение) -->
                <div class="mb-3">
                    <label class="form-label">Начало действия</label>
                    <input type="text" class="form-control" readonly
                           value="@Model.StartDate.ToString("dd.MM.yyyy")"/>
                    <!-- Скрытое поле для передачи StartDate в контроллер -->
                    <input asp-for="StartDate" type="hidden"
                           value="@Model.StartDate.ToString("yyyy-MM-dd")"/>
                </div>

                <!-- Окончание действия (редактируемое) -->
                <div class="mb-3">
                    <label class="form-label">Окончание действия</label>
                    <!-- Видимое поле для редактирования -->
                    <input type="date" class="form-control"
                           id="EndDateDisplay"
                           value="@Model.EndDate.ToString("yyyy-MM-dd")"/>
                    <!-- Скрытое поле для передачи в контроллер -->
                    <input asp-for="EndDate" type="hidden" id="EndDateHidden"
                           value="@Model.EndDate.ToString("yyyy-MM-dd")"/>
                    <small class="text-muted">Можно изменить вручную или автоматически при смене услуги</small>
                    <span asp-validation-for="EndDate" class="text-danger"></span>
                </div>

                <button type="submit" class="btn btn-primary">Сохранить изменения</button>
                <a asp-action="Index" class="btn btn-secondary">Отмена</a>
            </div>
        </div>
    </form>
</div>

@section Scripts {
    <script>
        document.addEventListener('DOMContentLoaded', function() {
            const serviceSelect = document.getElementById('ServiceSelect');
            const endDateDisplay = document.getElementById('EndDateDisplay');
            const endDateHidden = document.getElementById('EndDateHidden');
            const serviceInfo = document.getElementById('ServiceInfo');
            const serviceNameDisplay = document.getElementById('ServiceNameDisplay');
            const priceDisplay = document.getElementById('PriceDisplay');
            const durationDisplay = document.getElementById('DurationDisplay');

            // Исходные даты из модели
            const originalStartDate = new Date('@Model.StartDate.ToString("yyyy-MM-dd")');
            const originalEndDate = new Date('@Model.EndDate.ToString("yyyy-MM-dd")');

            // Функция синхронизации видимого и скрытого полей
            function syncEndDateFields() {
                const displayValue = endDateDisplay.value;
                if (displayValue) {
                    endDateHidden.value = displayValue;
                }
            }

            // Функция проверки валидности даты окончания
            function validateEndDate() {
                const selectedEndDate = new Date(endDateDisplay.value);
                if (selectedEndDate < originalStartDate) {
                    showToast('Ошибка', 'Дата окончания не может быть раньше начала действия абонемента!', 'danger');
                    endDateDisplay.value = originalEndDate.toISOString().split('T')[0];
                    syncEndDateFields();
            return false;
        }
        return true;
    }

    // Обработчик изменения видимого поля даты
    endDateDisplay.addEventListener('change', function() {
        if (validateEndDate()) {
            syncEndDateFields();
        }
    });

    // Обработчик изменения услуги (пересчёт только при явном выборе)
    serviceSelect.addEventListener('change', async function() {
        const serviceId = this.value;

        if (!serviceId) {
            serviceInfo.style.display = 'none';
            // Не трогаем сохранённую дату при отмене выбора услуги
            syncEndDateFields();
            return;
        }

        try {
            const response = await fetch(`/AbonnementSales/GetServiceDuration?serviceId=${serviceId}`);
            if (!response.ok) throw new Error('Ошибка сети');

            const data = await response.json();

            // Заполняем информацию об услуге
            serviceNameDisplay.textContent = data.serviceName;
            priceDisplay.textContent = data.price;
            durationDisplay.textContent = data.durationDays;
            serviceInfo.style.display = 'block';

            // Пересчитываем дату окончания на основе исходного StartDate
            const newEndDate = new Date(originalStartDate);
            newEndDate.setDate(originalStartDate.getDate() + data.durationDays);

            // Устанавливаем в видимое поле (формат yyyy-MM-dd для input[type=date])
            const formattedDate = newEndDate.toISOString().split('T')[0];
            endDateDisplay.value = formattedDate;
            syncEndDateFields(); // Синхронизируем с скрытым полем
        } catch (error) {
            console.error('Ошибка при получении данных:', error);
            showToast('Ошибка', 'Не удалось загрузить данные услуги. Проверьте подключение к сети.', 'danger');
            // Возвращаем сохранённую дату при ошибке
            syncEndDateFields();
        }
    });

    // ИНИЦИАЛИЗАЦИЯ ПРИ ЗАГРУЗКЕ — показываем сохранённую дату из БД
    // НЕ запускаем автоматический пересчёт!
    syncEndDateFields();

    // Функция показа всплывающего уведомления (toast)
    function showToast(title, message, type = 'info') {
        // Контейнер для тостов (создаём, если отсутствует)
        let toastContainer = document.getElementById('toast-container');
        if (!toastContainer) {
            toastContainer = document.createElement('div');
            toastContainer.id = 'toast-container';
            toastContainer.setAttribute('aria-live', 'polite');
            toastContainer.setAttribute('aria-atomic', 'true');
            toastContainer.style.position = 'fixed';
            toastContainer.style.bottom = '20px';
            toastContainer.style.right = '20px';
            toastContainer.style.zIndex = '1070';
            document.body.appendChild(toastContainer);
        }

        // Генерируем уникальный ID для тоста
        const toastId = 'toast-' + Date.now() + Math.random().toString(36).substr(2, 9);

        // Определяем стили по типу
        const typeClasses = {
            'success': 'bg-success text-white',
            'danger': 'bg-danger text-white',
            'warning': 'bg-warning text-dark',
            'info': 'bg-info text-white'
        };

        const currentTypeClass = typeClasses[type] || typeClasses['info'];

        // Создаём HTML тоста
        const toastHtml = `
            <div id="${toastId}" class="toast align-items-center ${currentTypeClass}" role="alert" aria-live="assertive" aria-atomic="true">
                <div class="d-flex">
                    <div class="toast-body">
                ${message}
            </div>
            <button type="button" class="btn-close btn-close-white me-2 m-auto" data-bs-dismiss="toast" aria-label="Close"></button>
        </div>
    </div>`;


        // Вставляем в контейнер
        toastContainer.insertAdjacentHTML('afterbegin', toastHtml);

        // Инициализируем и показываем
        const toastEl = document.getElementById(toastId);
        const toast = new bootstrap.Toast(toastEl, {
            autohide: true,
            delay: 5000 // Автоскрытие через 5 секунд
        });

        toast.show();

        // Удаляем элемент из DOM после скрытия
        toastEl.addEventListener('hidden.bs.toast', function () {
            this.remove();
        });
    }
});
</script>
}
